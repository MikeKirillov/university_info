Реализация и использование кастомных компараторов, применение полиморфизма, Java Stream API, использование сортировки в Stream API с указанием неконкретизированного компаратора
В этой части работы мы научимся (или вспомним, если уже умели) пользоваться на практике компараторами, создавать их реализации. Поймём на практике, для чего в Java можно удобно использовать работу с интерфейсами. Применим эти наши навыки для выполнения сортировки данных по различным параметрам, не разделяя её на несколько практически идентичных методов. Также узнаем об ещё одной очень полезной библиотеке от Apache.

В рамках всего проекта это даст нам возможность обеспечить пользователей различными вариантами сортировки данных, которые в перспективе будет легко использовать.

➡ В ходе работы потребуется:

Java Stream API;
интерфейсы;
реализация методов компаратора;
библиотека Apache Commons.
⭐ В этом уроке необходимо выполнить следующее:

Создать интерфейсы-компараторы для классов Student, University. Унаследовать их от класса Comparator<>.
Для каждого поля классов Student, University создать классы-компараторы, реализующие интерфейс созданных в п.1 компараторов.
При сравнении значений в методе compare() использовать методы соответствующих классов (Integer, Float, ...), для строковых значений использовать метод StringUtils.compare() библиотеки Apache Commons. Сравнение среднего балла студентов реализовать по убыванию.
Создать два enum, один — для перечисления вариантов компараторов класса Student, второй — класса University.
Создать утилитный класс (то есть класс, не позволяющий создать свой экземпляр, работающий исключительно по статическим методам), в котором реализовать два метода, принимающих на вход enum с типом компаратора, определяющих и возвращающих необходимый из реализованных компараторов.
Пояснение: на вход метода подаётся параметр, представляющий собой enum. Например, вот так: public static IMyComparator getMyComparator(MyEnum myEnum). Внутри метода по этому значению определяем, какую реализацию компаратора надо взять. На выходе метода, как видно из его описания, мы получаем тот или иной объект, реализующий наш интерфейс компаратора.

В методе main реализовать получение компаратора по типу (вызов метода утилитного класса). Сохранить полученные значения (то есть экземпляры компараторов) в переменные с типом интерфейса компаратора (аналогично тому, как в коллекциях делается List<T> someList = new ArrayList()).
В методе main заменить циклический вывод текстовой информации на использование Stream API. Перед выводом выполнить сортировку с использованием полученных компараторов. Вывод реализовать также в стриме с использованием синтаксиса ::
